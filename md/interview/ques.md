## xss过滤、sql注入

#### 预防XSS攻击，(参数/响应值)特殊字符过滤

一、什么是XSS攻击 

XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode

二、XSS漏洞的危害 
（1）网络钓鱼，包括盗取各类用户账号； 
（2）窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作； 
（3）劫持用户（浏览器）会话，从而执行任意操作，例如进行非法转账、强制发表日志
（4）强制弹出广告页面、刷流量等； 
（5）网页挂马； 
（6）进行恶意操作，例如任意篡改页面信息、删除文章等； 
（7）进行大量的客户端攻击，如DDoS攻击； 
（8）获取客户端信息，例如用户的浏览历史、真实IP、开放端口等； 
（9）控制受害者机器向其他网站发起攻击； 
（10）结合其他漏洞，如CSRF漏洞，实施进一步作恶； 
（11）提升用户权限，包括进一步渗透网站； 

##### 解决办法：

**增加过滤器来拦截处理，过滤非法的字符**



#### sql注入

**sql注入就是 在请求参数中传入sql的关键字   防止sql注入可以采用过滤器，替换掉请求中的关键字**





## netty线程模型

## 微服务和一些其他的

## redis分布式一些方案，挂掉了之后如何

宕机：服务器停止服务
如果只有一台redis，肯定会造成数据丢失，无法挽救
多台redis或者是redis集群 ，宕机则需要分为在主从模式下区分来看：

**slave从redis宕机**
配置主从复制的时候才配置从的redis，从的会从主的redis中读取主的redis的操作日志，求达到主从复制。
	1）在Redis中从库重新启动后会自动加入到主从架构中，自动完成同步数据；
	2）如果从数据库实现了持久化，可以直接连接到主的上面，只要实现增量备份（宕机到重新连接过程中，主的数据库发生数据操作，复制到从数据库），重新连接到主从架构中会实现增量同步。

**Master 宕机**
假如主从都没数据持久化，此时千万不要立马重启服务，否则可能会造成数据丢失，正确的操作如下：
在slave数据上执行SLAVEOF ON ONE,来断开主从关系并把slave升级为主库
此时重新启动主数据库，执行SLAVEOF,把它设置为从库，连接到主的redis上面做主从复制，自动备份数据。
以上过程很容易配置错误，可以使用redis提供的哨兵机制来简化上面的操作。简单的方法：redis的哨兵（sentinel）的功能。

**哨兵（sentinel）的原理**：

![](http://ww1.sinaimg.cn/large/007JYYsTgy1g2o6aoheg9j30q50ewgnx.jpg)

Redis提供了sentinel（哨兵）机制通过sentinel模式启动redis后，自动监控master/slave的运行状态，基本原理是：心跳机制+投票裁决。

每个sentinel会向其它sentinal、master、slave定时发送消息（哨兵定期给主或者从和slave发送ping包（IP：port），正常则响应pong，ping和pong就叫心跳机制），以确认对方是否“活”着，如果发现对方在指定时间（可配置）内未回应，则暂时认为对方已挂（所谓的“主观认为宕机” Subjective Down，简称SDOWN）。

若"哨兵群"中的多数sentinel，都报告某一master没响应，系统才认为该master"彻底死亡"(即：客观上的真正down机，Objective Down，简称ODOWN)，通过一定的vote算法，从剩下的slave节点中，选一台提升为master，然后自动修改相关配置。

[搭建哨兵的Redis](<https://blog.csdn.net/shouhuzhezhishen/article/details/69221517>)的方法

## http协议的字段和要点

4种类型的首部字段：通用的首部字段、请求首部、响应首部、实体首部字段

通用的首部字段名：Cache-Control（控制缓存）

请求首部：Host（服务器所在）

响应首部：ETag(资源的匹配信息)

实体首部：Content-Length、Content-Type(实体主体的大小和类型)、Expires

## 线程上下文切换

什么是CPU上下文：

CPU 寄存器和程序计数器就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前。



什么是CPU上下文切换：

就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。



类型：

根据任务的不同，可以分为以下三种类型

- 进程上下文切换
- 线程上下文切换
- 中断上下文切换

| 线程切换     | 同一进程中的两个线程之间的切换         |
| ------------ | -------------------------------------- |
| 进程切换     | 两个进程之间的切换                     |
| 模式切换     | 在给定线程中，用户模式和内核模式的切换 |
| 地址空间切换 | 将虚拟内存切换到物理内存               |

#### 减少切换

**让步式上下文切换**：指执行线程主动释放CPU，**与锁竞争严重程度成正比**，可通过减少锁竞争来避免；

**抢占式上下文切换**：指线程**因分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占**，一般由于线程数大于CPU可用核心数引起，可通过调整线程数，适当减少线程数来避免。

所以，减少上下文切换的方法**有无锁并发编程、CAS算法、使用最少线程和使用协程**。

> 1. **无锁并发**：多线程竞争时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash取模分段，不同的线程处理不同段的数据；
> 2. **CAS算法**：Java的Atomic包使用CAS算法来更新数据，而不需要加锁；
> 3. **最少线程**：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态；
> 4. **使用协程**：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换；