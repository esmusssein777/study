# MySQL索引

[toc]

## 索引常见模型

哈希表、有序数组和搜索树

### 哈希表

哈希表是一种以键 - 值(key-value)存储数据的结构，我们只要输入待查找的值即 key， 就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数 把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。

不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的 一种方法是，拉出一个链表。所以哈希索引的缺点是做区间查询的速度很慢。

所以，哈希表这种结构适用于只有等值查询的场景

###有序数组

有序数组在等值查询和范围查询场景中的性能就都非常优秀

查询时使用二分法来查询，这个时间复杂度是 O(log(N))。在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高

所以，有序数组索引只适用于静态存储引擎，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。

### 二叉树

二叉搜索树的特点是:每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查，按照搜索顺序这个时间复杂度是 O(log(N))。

当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。

树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。

你可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数 据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。

以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一 个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。

## InnoDB 的索引模型

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。

每一个索引在 InnoDB 里面对应一棵 B+ 树。

假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。 这个表的建表语句是:

```
mysql> create table T( 
id int primary key,
k int not null,
name varchar(16),
index (k)
)engine=InnoDB;
```

表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树 的示例示意图如下。

<img src="https://cdn.jsdelivr.net/gh/guangzhengli/ImgURL@master/uPic/R0Vc7R.png" alt="R0Vc7R" style="zoom:50%;" />

从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。

主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引 (clustered index)。

非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引 (secondary index)。

根据上面的索引结构说明，我们来讨论一个问题:基于主键索引和普通索引的查询有什么 区别?

如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树;

如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引 树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

### 覆盖索引

如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行?

现在，我们一起来看看这条 SQL 查询语句的执行流程:

1. 在 k 索引树上找到 k=3 的记录，取得 ID = 300;
2.  2. 再到 ID 索引树查到 ID=300 对应的 R3;

3. 在 k 索引树取下一个值 k=5，取得 ID=500;

4. 再回到 ID 索引树查到 ID=500 对应的 R4;

5. 在 k 索引树取下一个值 k=6，不满足条件，循环结束。

在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读 了 k 索引树的 3 条记录(步骤 1、3 和 5)，回表了两次(步骤 2 和 4)。

如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的 值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是 说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。



基于上面覆盖索引的说明，我们来讨论一个问题:在一个市民信息表上，是否有必要将身份证号和名字建立联合索引?

假设这个市民表的定义是这样的:

```
CREATE TABLE `tuser` (
`id` int(11) NOT NULL,
`id_card` varchar(32) DEFAULT NULL,
`name` varchar(32) DEFAULT NULL, 
`age` int(11) DEFAULT NULL, 
`ismale` tinyint(1) DEFAULT NULL, 
PRIMARY KEY (`id`),
KEY `id_card` (`id_card`),
KEY `name_age` (`name`,`age`) 
) ENGINE=InnoDB
```

我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个(身份证号、姓名)的联合索引，是不是浪费空间?

如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。

当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权 衡考虑了

### 最左前缀原则

看到这里你一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。如果我现在要按照市民的身份证号去查他的家庭地址呢?虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧?反过来说，单独为一个不频繁的请求创建一个(身份证号，地址)的索引又感觉有点浪费。应该怎么做呢?

这里，我先和你说结论吧。B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。

为了直观地说明这个概念，我们用(name，age)这个联合索引来分析。

<img src="https://cdn.jsdelivr.net/gh/guangzhengli/ImgURL@master/uPic/iS3LU2.png" alt="iS3LU2" style="zoom:50%;" />

可以看到，索引项是按照索引定义里面出现的字段顺序排序的。

当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历 得到所有需要的结果。

如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是"where name like ‘张 %’"。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然 后向后遍历，直到不满足条件为止。

可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这 个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。

基于上面对最左前缀索引的说明，我们来讨论一个问题:在建立联合索引的时候，如何安排索引内的字段顺序。

这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

所以现在你知道了，这段开头的问题里，我们要为高频请求创建 (身份证号，姓名)这个 联合索引，并用这个索引支持“根据身份证号查询地址”的需求。

那么，如果既有联合查询，又有基于 a、b 各自的查询呢?查询条件里面只有 b 的语句， 是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要 同时维护 (a,b)、(b) 这两个索引。

这时候，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个(name,age) 的联合索引和一个 (age) 的单字段 索引。

### 索引下推

上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢?

我们还是以市民表的联合索引(name, age)为例。如果现在有一个需求:检索出表 中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的:

```
mysql> select * from tuser where name like '张 %' and age=10 and ismale=1;
```

你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第 一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。

在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字 段值。

而 MySQL 5.6 引入的索引下推优化(index condition pushdown)， 可以在索引遍历过 程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

<img src="https://cdn.jsdelivr.net/gh/guangzhengli/ImgURL@master/uPic/15OSYr.png" alt="15OSYr" style="zoom:50%;" />

### 例子

```
CREATE TABLE `geek` (
`a` int(11) NOT NULL, 
`b` int(11) NOT NULL, 
`c` int(11) NOT NULL,
`d` int(11) NOT NULL,
PRIMARY KEY (`a`,`b`),
KEY `c` (`c`),
KEY `ca` (`c`,`a`), 
KEY `cb` (`c`,`b`) 
) ENGINE=InnoDB;
```

有查询条件

```
select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
```

所以建立了 ‘ca’, 'cb' 两个索引

结论： ca 没有必要， cb 有必要

原因： ca索引，通过索引对数据进行筛选，回表的时候，a本身就是主键索引，所以可以保证有序，所以ca 的索引和 c 的索引是一模一样的 ; cb索引，b上并没有索引，ab索引也无法满足最左匹配原则，可以保留加快排序速度。

### 索引维护

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例， 如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。

而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。

除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。

自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。

除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢?

由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级 索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整 型(bigint)则是 8 个字节。

显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

## 唯一索引

假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了 不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这 样的 SQL 语句:

```
select name from CUser where id_card = 'xxxxxxxyyyyyyzzzzz';
```

所以，你一定会考虑在 id_card 字段上建索引。从性能的角度考虑，你选择唯一索引还是普通索引呢?选择的依据是什么呢?

### 查询过程

假设，执行查询的语句是 select id from T where k=5。这个查询语句在索引树上查找的 过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据 页，然后可以认为数据页内部通过二分法来定位记录。

* 对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录， 直到碰到第一个不满足 k=5 条件的记录。

* 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

那么，这个不同带来的性能差距会有多少呢?答案是，微乎其微。

你知道的，InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。

因为引擎是按页读写的，所以说，当找到 k=5 的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。

当然，如果 k=5 这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。

但是，我们之前计算过，对于整型字段，一个数据页可以放近千个 key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的 CPU 来说可以忽略不计。

### 更新过程

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。

因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。

如果在更新时，这个记录要更新的目标页不在内存中。这时，InnoDB 的处理流程如下:

* 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束;

* 对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。

## 选错索引

往表 t 中插入 10 万行记录，取值按整数递增，即:(1,1,1)，(2,2,2)，(3,3,3) 直到 (100000,100000,100000)。

```
CREATE TABLE `t` (
`id` int(11) NOT NULL,
`a` int(11) DEFAULT NULL, 
`b` int(11) DEFAULT NULL, 
PRIMARY KEY (`id`),
KEY `a` (`a`),
KEY `b` (`b`) 
)ENGINE=InnoDB;
```

```
delimiter ;;
create procedure idata() 
begin
	declare i int; 
	set i=1; 
	while(i<=100000)do
		insert into t values(i, i, i);
		set i=i+1; 
		end while;
end;; 
delimiter ; 
call idata();
```

```
explain select * from t where a between 10000 and 20000;
```

得到的结果是我们所需要的，扫描了10001行，使用了 a 作为索引

![y2tImO](https://cdn.jsdelivr.net/gh/guangzhengli/ImgURL@master/uPic/y2tImO.png)

发现做了全表扫描，也就是10万行。如果使用 `select * from t force index(a) where a between 10000 and 20000;`来使用强制使用 a 索引，只用扫描 1万行。

这是因为，在事务A还没有提交的时候，事务B删除了10万行的数据不能删除，数据的每一行都有两个版本，这样，索引 a 上就有两份。

优化器得到索引的基数时，预计扫描的行数比原来多了很多，比如原来扫描1万行，现在扫描3万行。尽管还是比10万行的全表扫描要少，但是需要把索引拿出来后回表的代价也算进去。所以优化器选择全表扫描。

解决方法

* force index(a) 来强制使用
* analyze table t 命令，可以用来重新统计索引信息，让预估重新回到 1 万行

如果有这样的查询语句

```
select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;
```

如果使用索引 a 进行查询，那么就是扫描索引 a 的前 1000 个值，然后取到对应的 id，再 到主键索引上去查出每一行，然后根据字段 b 来过滤。显然这样需要扫描 1000 行。

如果使用索引 b 进行查询，那么就是扫描索引 b 的最后 50001 个值，与上面的执行过程 相同，也是需要回到主键索引上取值再判断，所以需要扫描 50001 行。

所以你一定会想，如果使用索引 a 的话，执行速度明显会快很多。结果数据库还是选择了 b 索引。

优化器选择使用索引 b，是因为它认为使用索引 b 可以避免排序(b 本身是索引，已经是有序的了，如果选择索引 b 的话，不需要再做排序，只需要遍历)，所以即使扫描行数多，也判定为代价更小。

但是实际上选择 a 索引的代价远比 b 要小。我们如果要纠正选择错误。可以

* force index(a) 来强制使用。但是不够优雅
* 改成 order by b,a。让数据库认为 a 也需要排序。所以会使用 a 索引
* 删除 b 索引

## 字符索引

```
alter table SUser add index index1(email);完整索引
```

```
alter table SUser add index index2(email(6));前缀索引
```

为了解决前缀索引可能导致增加很多的扫描次数，我们依次选取不同长度的前缀来看这个值，比如我们要看一下 4~7 个字节的前缀索引， 可以用这个语句

```
select 
count(distinct left(email,4))as L4, 
count(distinct left(email,5))as L5,
count(distinct left(email,6))as L6,
count(distinct left(email,7))as L7,
from SUser; 
```

选择合适的长度来创建前缀索引。

还有像身份证这种前缀不够区分度的，可以来倒序存储。或者加一个字段专门来存校验码。

总结：

1. 直接创建完整索引，这样可能比较占用空间;

2. 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引;

3. 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题;

4. 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。

在实际应用中，你要根据业务字段的特点选择使用哪种方式。

