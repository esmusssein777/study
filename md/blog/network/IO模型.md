# I/O 模型

UNIX 系统下的 I/O 模型有 5 种:同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O。但是我们要思考一个问题，到底什么是 I/O ?

***所谓的I/O 就是计算机内存与外部设备之间拷贝数据的过程***

我们知道 CPU 访问内存的速度远远高于外部设备，因此 CPU 是先把外部设备的数据读到内存里，然后再进行处理。请考虑一下这个场景，当你的程序通过 CPU 向外部设备发出一个读指令时，数据从外部设备拷贝到内存往往需要一段时间，这个时候 CPU 没事干了，你的程序是主动把 CPU 让给别人?还是让 CPU 不停地查:数据到了吗......

这就是 I/O 模型要解决的问题。



对于一个网络 I/O 通信过程，比如网络数据读取，会涉及两个对象，一个是调用这个 I/O 操作的用户线程，另外一个就是操作系统内核。一个进程的地址空间分为用户空间和内核空间，用户线程不能直接访问内核空间。

当用户线程发起 I/O 操作后，网络数据读取操作会经历两个步骤:

* 用户线程等待内核将数据从网卡拷贝到内核空间。

* 内核将数据从内核空间拷贝到用户空间。

**各种 I/O 模型的区别就是:它们实现这两个步骤的方式是不一样的**



**同步阻塞 I/O** : 用户线程发起 read 调用后就阻塞了，让出 CPU。内核等待网卡数据到来， 把数据从网卡拷贝到内核空间，接着把数据拷贝到用户空间，再把用户线程叫醒。

<img src="/Users/guangzheng.li/Library/Application Support/typora-user-images/image-20210329211953992.png" alt="image-20210329211953992" style="zoom:50%;" />



**同步非阻塞 I/O** : 用户线程不断的发起 read 调用，数据没到内核空间时，每次都返回失败，直到数据到了内核空间，这一次 read 调用后，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的，等数据到了用户空间再把线程叫醒

<img src="/Users/guangzheng.li/Library/Application Support/typora-user-images/image-20210329212200687.png" alt="image-20210329212200687" style="zoom:50%;" />



**I/O 多路复用** : 用户线程的读取操作分成两步了，线程先发起 select 调用，目的是问内核数据准备好了吗?等内核把数据准备好了，用户线程再发起 read 调用。在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。那为什么叫 I/O 多路复用呢? 因为一 次 select 调用可以向内核查多个数据通道(Channel)的状态，所以叫多路复用。

<img src="https://cdn.jsdelivr.net/gh/guangzhengli/ImgURL@master/uPic/WQSLi1.png" alt="WQSLi1" style="zoom:50%;" />



**异步 I/O** : 用户线程发起 read 调用的同时注册一个回调函数，read 立即返回，等内核将数据准备好后，再调用指定的回调函数完成处理。在这个过程中，用户线程一直没有阻塞。

<img src="/Users/guangzheng.li/Library/Application Support/typora-user-images/image-20210329212723651.png" alt="image-20210329212723651" style="zoom:50%;" />



异步最大的特点是，应用程序不需要自己去触发数据从内核空间到用户空间的拷贝。

为什么是应用程序去“触发”数据的拷贝，而不是直接从内核拷贝数据呢?这是因为应用程序是不能访问内核空间的，因此数据拷贝肯定是由内核来做，关键是谁来触发这个动作。

是内核主动将数据拷贝到用户空间并通知应用程序。还是等待应用程序通过 Selector 来查询，当数据就绪后，应用程序再发起一个 read 调用，这时内核再把数据从内核空间拷贝到用户空间。

需要注意的是，数据从内核空间拷贝到用户空间这段时间，应用程序还是阻塞的。所以你会看到异步的效率是高于同步的，因为异步模式下应用程序始终不会被阻塞。

异步的工作过程：

* 首先，应用程序在调用 read API 的同时告诉内核两件事情: 数据准备好了以后拷贝到哪个 Buffer，以及调用哪个回调函数去处理这些数据。

* 之后，内核接到这个 read 指令后，等待网卡数据到达，数据到了后，产生硬件中断，内核 在中断程序里把数据从网卡拷贝到内核空间，接着做 TCP/IP 协议层面的数据解包和重组， 再把数据拷贝到应用程序指定的 Buffer，最后调用应用程序指定的回调函数。

## 总结

I/O 模型是为了解决内存和外部设备速度差异的问题。我们平时说的阻塞或非阻塞是指应用程序在发起 I/O 操作时，是立即返回还是等待。而同步和异步，是指应用程序在与内核通信时，数据从内核空间到应用空间的拷贝，是由内核主动发起还是由应用程序来触发。