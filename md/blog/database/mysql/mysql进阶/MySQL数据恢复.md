# MySQL数据恢复

[toc]

## 误删行

如果是使用 delete 语句误删了数据行，可以用 Flashback 工具通过闪回把数据恢复回来。

Flashback 恢复数据的原理，是修改 binlog 的内容，拿回原库重放。而能够使用这个方 案的前提是，需要确保 binlog_format=row 和 binlog_row_image=FULL。

具体恢复数据时，对单个事务做如下处理:

1. 对于 insert 语句，对应的 binlog event 类型是 Write_rows event，把它改成 Delete_rows event 即可;

2. 同理，对于 delete 语句，也是将 Delete_rows event 改为Write_rows event;

3. 而如果是 Update_rows 的话，binlog 里面记录了数据行修改前和修改后的值，对调这两行的位置即可。

需要说明的是，我不建议你直接在主库上执行这些操作。恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。

把 sql_safe_updates 参数设置为 on。这样一来，如果我们忘记在 delete 或者 update 语句中写 where 条件，或者 where 条件里面没有包含索引字段的话，这条语句的执行就会报错。

使用 delete 命令删除的数据，你还可以用 Flashback 来恢复。而使用 truncate /drop table 和 drop database 命令删除的数据，就没办法通过 Flashback 来恢复了。这是因为，即使我们配置了 binlog_format=row，执行这三个命令时，记录的 binlog 还是 statement 格式。binlog 里面就只有一个 truncate/drop 语句，这些信息是恢复不出数据的。

## 误删库 **/** 表

这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求

线上有定期的全量备份，并且实时备份 binlog。

在这两个条件都具备的情况下，假如有人中午 12 点误删了一个库，恢复数据的流程如 下:

1. 取最近一次全量备份，假设这个库是一天一备，上次备份是当天 0 点; 
2. 用备份恢复出一个临时库;

3. 从日志备份里面，取出凌晨 0 点之后的日志;

4. 把这些日志，除了误删除数据的语句外，全部应用到临时库。

关于这个过程，我需要和你说明如下几点:

1. 为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用 mysqlbinlog 命 令时，加上一个–database 参数，用来指定误删表所在的库。这样，就避免了在恢复数 据时还要应用其他库日志的情况。

2. 在应用日志的时候，需要跳过 12 点误操作的那个语句的 binlog: 

   * 如果原实例没有使用 GTID 模式，只能在应用到包含 12 点的 binlog 文件的时候， 先用–stop-position 参数执行到误操作之前的日志，然后再用–start-position 从误 操作之后的日志继续执行;

   * 如果实例使用了 GTID 模式，就方便多了。假设误操作命令的 GTID 是 gtid1，那么 只需要执行 set gtid_next=gtid1;begin;commit; 先把这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 的时候，就会自动跳过误操作的语句。

不过，即使这样，使用 mysqlbinlog 方法恢复数据还是不够快，主要原因有两个:

1. 如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是 mysqlbinlog 工具并不能指定只解析一个表的日志;
2. 过程是单线程

一种加速的方法是，在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从 库，这样:

1. 在 start slave 之前，先通过执行change replication filter replicate_do_table = (tbl_name) 命令，就可以让临时库只同步误操作的表;

2. 这样做也可以用上并行复制技术，来加速整个数据恢复过程。

### 延迟复制备库

如果有非常核心的业务，不允许太长的恢复时间，我们可以考虑搭建延迟复制的备库。这 个功能是 MySQL 5.6 版本引入的。

一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。

延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY = N 命令，可以指定这个备库持续保持跟主库有 N 秒的延迟。

## **rm** 删除数据

对于一个有高可用机制的 MySQL 集群来说，最不怕的就是 rm 删除数据了。只要 不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA 系统就会开 始工作，选出一个新的主库，从而保证整个集群的正常工作。

这时，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。